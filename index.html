<!doctype html>
<html>

<head>
<title>jFluidic</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script type="text/javascript" src="glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="class.js"></script>
<script type="text/javascript" src="jquery.js"></script>

<script id="inject-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec2 vTextureCoord;
    
    uniform vec2 uPosition;
    uniform vec4 uVelocity;
    uniform sampler2D uVectorField;
    
    void main(void) {
        if (length(uPosition - vTextureCoord) < 0.04) {
            gl_FragColor = uVelocity;
        } else {
            gl_FragColor = texture2D(uVectorField, vTextureCoord);
        }
    }
</script>

<script id="neighbours-util" type="x-shader/x-fragment">
void F4Neighbours2D(sampler2D tex,
					 vec2 s,
					 out vec4 left,
					 out vec4 right,
					 out vec4 up,
					 out vec4 down)
{
	vec3 p  = vec3(-1, 0, 1)/256.0;
	
	down = texture2D(tex, s + p.yx);
	up = texture2D(tex, s + p.yz);
	left = texture2D(tex, s + p.xy);
	right = texture2D(tex, s + p.zy);
}
</script>

<script id="jacobi-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec2 vTextureCoord;
    
    uniform sampler2D uX;
    uniform sampler2D uB;
    uniform float uAlpha;
    uniform float uBeta;
    
    void main(void) {
    	vec4 left, right, up, down;
  
    	vec4 current = texture2D(uX, vTextureCoord);
    	F4Neighbours2D(uB, vTextureCoord, left, right, up, down);
    	
    	gl_FragColor = (current + uAlpha*(left + right + up + down)) / uBeta;
    	//gl_FragColor = left;
    }
</script>

<script id="divergence-fs" type="xshader/x-fragment">
    precision mediump float;
    
    varying vec2 vTextureCoord;
    uniform sampler2D uVectorField;
    
    void main() {
    	vec4 left, right, up, down;
    	F4Neighbours2D(uVectorField, vTextureCoord, left, right, up, down);
    	float result  = -0.5*((right.x - left.x) + (up.y - down.y))/256.; // division by 256 really not necessary - why bother?
    	gl_FragColor = vec4(result,0,0,0); // FIXME: Make 1-D
    }
</script>

<script id="subtract-pressure-gradient-fs" type="xshader/x-fragment">
    precision mediump float;    

    varying vec2 vTextureCoord;
    uniform sampler2D uVectorField;
    uniform sampler2D uPressure;
    
    void main(void) {
    	vec4 left, right, up, down;    	
      	F4Neighbours2D(uPressure, vTextureCoord, left, right, up, down);
    
    	vec4 result = texture2D(uVectorField, vTextureCoord);
    	result.x -= 0.5 * 256.*(right.x - left.x); // multiplication by 256 really not necessary - why bother?
    	result.y -= 0.5 * 256.*(up.x - down.x);
    	gl_FragColor = vec4(result.xy, 0, 1); // FIXME: Make 1-D
	}
</script>

<script id="bilerp-util" type="x-shader/x-fragment">
vec4 bilerp(sampler2D tex, vec2 s) {
      vec4 st;
      
      s = s * 256.0;
      st.xy = (floor(s - 0.5) + 0.5);
      st.zw = st.xy + 1.0;
      vec2 t = s - st.xy;
      st = st / 256.0;
                
      vec4 tex11 = texture2D(tex, st.xy);
      vec4 tex21 = texture2D(tex, st.zy);
      vec4 tex12 = texture2D(tex, st.xw);
      vec4 tex22 = texture2D(tex, st.zw);
      
      // bilinear interpolation
      return mix(mix(tex11, tex21, t.x), mix(tex12, tex22, t.x), t.y);
}
</script>

<script id="advect-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec2 vTextureCoord;
    
    uniform sampler2D uAffectedField;
    uniform sampler2D uVectorField;
    uniform float uDt;
    
    void main(void) {
        float speed = 30.0;
        vec4 velocity = texture2D(uVectorField, vTextureCoord);
        vec2 lastPosition = vTextureCoord - velocity.xy * uDt * speed/256.0;
        
        gl_FragColor = bilerp(uAffectedField, lastPosition);
    }
</script>

<script id="perturb-fs" type="x-shader/x-fragment">

    precision mediump float;
    
    varying vec2 vTextureCoord;
    
    uniform sampler2D uAffectedField;
    uniform sampler2D uVectorField;
    uniform float uDt;
    
    void main(void) {
        
        vec4 velocity = texture2D(uVectorField, vTextureCoord);
        vec4 color =  texture2D(uAffectedField, vTextureCoord);
        
        //velocity.x = 1.0;//velocity.x + color.r * uDt;
        velocity.y = velocity.y + (color.r - color.b) * uDt;
        velocity.a = velocity.y;
        
        gl_FragColor = velocity;
    }
</script>

<script id="draw-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec4 vColor;
    varying vec2 vTextureCoord;
    
    uniform sampler2D uVectorField;
    uniform float uDt;
    
    void main(void) {
        gl_FragColor = vec4(1,0,1,1);
        gl_FragColor = texture2D(uVectorField, vTextureCoord);
        gl_FragColor = abs(gl_FragColor);
    }
</script>
<script id="debug-draw-fs" type="x-shader/x-fragment">
    precision mediump float;
    
    varying vec4 vColor;
    varying vec2 vTextureCoord;
    
    uniform sampler2D uVectorField;
    uniform float uDt;
    
    void main(void) {
        //gl_FragColor = vec4(1,0,1,1);
        gl_FragColor = texture2D(uVectorField, vTextureCoord);
        gl_FragColor.a = 1.;
        gl_FragColor = abs(gl_FragColor);
    }
</script>
<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec2 aTextureCoord;
    
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;

    varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vTextureCoord = aTextureCoord;
    }
</script>


<script>

Program = Class.extend({
    construct: function(context, sourceCode) {
        this._context = context;
        this._source = sourceCode;
    },
    
    loadAssets: function() {
        this._fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(this._fragmentShader, this._source);
        gl.compileShader(this._fragmentShader);
        
        if (!gl.getShaderParameter(this._fragmentShader, gl.COMPILE_STATUS))
            throw "FAILED TO COMPILE SHADER: \n" + gl.getShaderInfoLog(this._fragmentShader) + this._source;
            
        this._program = this._context.createProgram(this._fragmentShader);
        console.log("Loaded " + this._source);
    },
    
    go: function(bindings) {
        gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
        
        gl.useProgram(this._program);
        this._setupParameters(bindings);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, UsedEverywhere.Vertices.numItems);
        
    },
    
    _setupParameters: function(bindings) {
        this._bindBuffer(this._program.arguments.vertices, UsedEverywhere.Vertices);
        this._bindBuffer(this._program.arguments.textureCoords, UsedEverywhere.TextureCoords);
    
        var textureNumber = 0;
        for(var i=0; i < bindings.length; i++) {
            var binding = bindings[i];
            
            if (binding.type == 'texture') {
                gl.activeTexture(gl['TEXTURE' + textureNumber]);
                gl.bindTexture(gl.TEXTURE_2D, binding.value);
                gl.uniform1i(this._program.uniform[binding.name], textureNumber);
                
                textureNumber++;
            } else {
                gl[binding.type](this._program.uniform[binding.name], binding.value);
            }  
        }
    
    },
    
    _bindBuffer: function(argument, buffer) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.vertexAttribPointer(argument, buffer.itemSize, gl.FLOAT, false, 0, 0);
    
    },
});
var SolveProgram = Class.extend({
    construct: function(renderer, program) {
        this._renderer = renderer;
        this._program = program;
    },
    
    go: function(bindings, destination) {
        this._renderer.begin();
        this._program.go(bindings);
        this._renderer.end(destination);
    }
});

var Solver = Class.extend({
    construct: function(renderer) {
        this._renderer = renderer;
    },
    
    go: function(program, bindings, destination) {
        this._renderer.begin();
        program.go(bindings);
        this._renderer.end(destination);
    }
});

var InjectProgram = Program.extend({
    construct: function(context, sourceCode) {
        this._super(context, sourceCode);
    },
});

var Renderer = Class.extend({
    construct: function(framebuffer, renderbuffer, textureManager) {
        this._framebuffer = framebuffer;
        this._renderbuffer = renderbuffer;
        this._textureManager = textureManager;
    },
    
    begin: function() {
        gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebuffer);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._textureManager.buffer(), 0);
    },
    
    end: function(destination) {
        //gl.bindTexture(gl.TEXTURE_2D, this._textureManager.buffer());
        //gl.generateMipmap(gl.TEXTURE_2D);
        //gl.bindTexture(gl.TEXTURE_2D, null);
        
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        this._textureManager.swap(destination);
    }
});

var SolveContext = Class.extend({
    construct: function(vertexShader) {
        this._vertexShader = vertexShader;
    },
    
    createProgram: function(fragmentShader) {
        var program = gl.createProgram();
        // TODO: Put utils shaders in here, instead of dodgy string concat
        gl.attachShader(program, this._vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) 
            throw "Failed initialization of shader";
                
        gl.useProgram(program);
        program.arguments = {
            vertices: gl.getAttribLocation(program, "aVertexPosition"),
            textureCoords: gl.getAttribLocation(program, "aTextureCoord")
        };
        gl.enableVertexAttribArray(program.arguments.vertices);
        gl.enableVertexAttribArray(program.arguments.textureCoords);
        
        // LOLOLOLOLOLOL do this per-program, srsly FIXME
        program.uniform = {
            projectionMatrix: gl.getUniformLocation(program, 'uPMatrix'),
            modelViewMatrix: gl.getUniformLocation(program, 'uMVMatrix'),
            vectorField: gl.getUniformLocation(program, 'uVectorField'),
            affectedField: gl.getUniformLocation(program, 'uAffectedField'),
            pressure: gl.getUniformLocation(program, 'uPressure'),
            dt: gl.getUniformLocation(program, 'uDt'),
            position: gl.getUniformLocation(program, 'uPosition'),
            velocity: gl.getUniformLocation(program, 'uVelocity'),
            x: gl.getUniformLocation(program, 'uX'),
            b: gl.getUniformLocation(program, 'uB'),
            alpha: gl.getUniformLocation(program, 'uAlpha'),
            beta: gl.getUniformLocation(program, 'uBeta')
        };
    
        // Uniforms are unchanging!    
        gl.uniformMatrix4fv(program.uniform.projectionMatrix, false, UsedEverywhere.ProjectionMatrix);
        gl.uniformMatrix4fv(program.uniform.modelViewMatrix, false, UsedEverywhere.ModelViewMatrix);
    
        return program
    }
});

var TextureLoader = Class.extend({
    create: function(size) {
        if (!gl.getExtension('OES_texture_float')) {
            var text = 'This demo requires the OES_texture_float extension';
            throw text;
          }
      
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); // Linear?
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.FLOAT, null);
        gl.bindTexture(gl.TEXTURE_2D, null);
        return texture;
    }
});

var TextureManager = Class.extend({
    construct: function(vectorField, buffer, divergenceField, pressure, ink) {
        this._vectorField = vectorField;
        this._buffer = buffer;
        this._divergenceField = divergenceField;
        this._pressure = pressure;
        this._ink = ink;
    },
   
    vectorField: function(value) {
        return this._vectorField = (value === $.undefined ? this._vectorField : value);
    },
        
    buffer: function(value) {
        return this._buffer = (value === $.undefined ? this._buffer : value);
    },
    
    divergenceField: function(value) {
        return this._divergenceField = (value === $.undefined ? this._divergenceField : value);
    },
    
    pressure: function(value) {
        return this._pressure = (value === $.undefined ? this._pressure : value);
    },
    
    ink: function(value) {
        return this._ink = (value === $.undefined ? this._ink : value);
    },
    
    swap: function(fn) {
        var tmp = this.buffer();
        this.buffer(fn.call(this));
        fn.call(this, tmp);
    }    
});

var ProgramLoader = Class.extend({
    construct: function(context) {
        this._context = context;
    },

    load: function(fragmentName, utilScripts) {
        if (!utilScripts) utilScripts = [];
        var programSource = 'precision mediump float;';
        for (var i=0; i < utilScripts.length; i++) {
            programSource += document.getElementById(utilScripts[i] + '-util').innerText;
        }
        programSource += document.getElementById(fragmentName + '-fs').innerText;
        
        var perturbProgram = new Program(this._context, programSource);
        perturbProgram.loadAssets();
        
        return perturbProgram;
    }
});

var UsedEverywhere = {
    setup: function() {
        var createBuffer = function(data, itemSize, numItems) {
            var buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
            buffer.itemSize = itemSize;
            buffer.numItems = numItems;
            return buffer;
        };
        
        UsedEverywhere.Vertices = createBuffer([1,1,0,  0,1,0,  1,0,0,  0,0,0], 3, 4);
        UsedEverywhere.TextureCoords = createBuffer([1,1, 0,1, 1,0, 0,0], 2, 4);
        
        UsedEverywhere.ProjectionMatrix = mat4.create();
        mat4.ortho(0,1,0,1,0,1, UsedEverywhere.ProjectionMatrix);
        
        UsedEverywhere.ModelViewMatrix = mat4.create();
        mat4.identity(UsedEverywhere.ModelViewMatrix);
    }
};

var gl,
    shaderProgram,
    squareVertexPositionBuffer, squareColorBuffer, squareTextureCoordBuffer,
    pMatrix = mat4.create(),
    mvMatrix = mat4.create(),
    texture,
    rttFramebuffer,
    rttTexture
    ;
    
function webGlStart() {
    var canvas = document.getElementById('dest');
    initGl(canvas);
    UsedEverywhere.setup();

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, document.getElementById('shader-vs').innerText);
    gl.compileShader(vertexShader);

    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    framebuffer.width = 256;
    framebuffer.height = 256;
    
    var renderbuffer = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 256, 256);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      
    var textureLoader = new TextureLoader();
    var vectorField = textureLoader.create(256);
    var buffer = textureLoader.create(256);
    var divergenceField = textureLoader.create(256);
    var pressure = textureLoader.create(256);
    var ink = textureLoader.create(256);
    
    var textureManager = new TextureManager(vectorField, buffer, divergenceField, pressure, ink);
    var context = new SolveContext(vertexShader);
    
    var renderer = new Renderer(framebuffer, renderbuffer, textureManager);
    var programLoader = new ProgramLoader(context);
    var textureLoader = new TextureLoader(context);
    var solver = new Solver(renderer);
    
    var perturbProgram = programLoader.load('perturb', [], { vectorField: { type: 'texture', shaderVariable: 'uVectorField' }});    
    var advectProgram = programLoader.load('advect', ['bilerp']);    
    var injectProgram = programLoader.load('inject');    
    var jacobiProgram = programLoader.load('jacobi', ['neighbours'])    
    var divergenceProgram = programLoader.load('divergence', ['neighbours']);    
    var subtractPressureGradientProgram = programLoader.load('subtract-pressure-gradient', ['neighbours']);    
    var drawProgram = programLoader.load('draw');
    
    var debugDrawProgram = programLoader.load('debug-draw');
    
    gl.clearColor(0,0,0,1);
    gl.enable(gl.DEPTH_TEST);
    gl.viewport(0,0,gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    var textureParam = function(name, texture) {
        return {
            type: 'texture', name: name, value: texture
        };
    };
    var currentTextureParam = function() { 
        return textureParam('vectorField', textureManager.vectorField());
    };
    
    var debugTexture = function(textureName) {
        if (!$('#debug-' + textureName).is(":checked")) return;
        debugDrawProgram.go([textureParam(textureName, textureManager[textureName]())]);
        $('#' + textureName).attr('src', $('canvas')[0].toDataURL());
        
    }
    
    var solveLinearSystem = function(x, b, destination, alpha, beta) {
        for (var i=0; i < 20; i++) {
            solver.go(jacobiProgram, [
                { name: 'x', type: 'texture', value: x.call(textureManager) },
                { name: 'b', type: 'texture', value: b.call(textureManager) },
                { name: 'alpha', type: 'uniform1f', value: alpha }, 
                { name: 'beta', type: 'uniform1f', value: beta } 
            ], destination);
        }
    };
    
    var injectPosition = null;
    var injectVelocity = function(el, event) {
        var injectR = $(el).data('button1') ? 1 : 0;
        var injectB = $(el).data('button3') ? 1 : 0;
        
        if (!injectR && !injectB) {
            injectPosition = null;
            return;
        }
        
        var position = [event.offsetX/256.0, 1-event.offsetY/256.0];
        var velocity = [injectR, 0, injectB, 1];
        //if (event.ctrlKey) { velocity[0] *= -1; velocity[1] *= -1; velocity[2] = 1 };
        
        injectPosition = [
            { type: 'uniform2fv', name: 'position', value: position }, 
            { type: 'uniform4fv', name: 'velocity', value: velocity },
        ];
        
    };
    $('canvas').mousedown(function(event) {
        $(this).data('button'+event.which, true);
        injectVelocity(this, event);
        return false;
    });
    $('canvas').mousemove(function(event) {
        injectVelocity(this, event);
        return false;
    });
    
    $('canvas').mouseout(function(event) { $(this).data('button1', false).data('button3', false); injectVelocity(this, event); return false; });
    $('canvas').mouseup(function(event) { $(this).data('button' + event.which, false); injectVelocity(this, event); return false; });
    $(document).bind('contextmenu', function(event) {  return false; });
    
    setTimeout(function() {
        drawProgram.go([currentTextureParam()]);
        
        var frameNumber = 0;
        var time = Date.now();
        var frameStart = time;
        var maxSecondsBetweenFrames = 0.01;
        var maxSolvesPerSecond = 2000;
       
        setInterval(function() {
            
            if (!$('#go').is(':checked')) {
                return;
            }
            
            var singleStep = $("#single-step").is(":checked");
            var timeThisFrame = 0;
            var solvesThisFrame = 0;
            
            while(timeThisFrame < maxSecondsBetweenFrames && solvesThisFrame < maxSolvesPerSecond*maxSecondsBetweenFrames && (!singleStep || solvesThisFrame == 0) ) {
                if (injectPosition) {
                    injectParam = [textureParam('ink', textureManager.ink())];
                    injectParam.push(injectPosition[0]);
                    injectParam.push(injectPosition[1]);
                    solver.go(injectProgram, injectParam, textureManager.ink);
                    //injectSolver.go(injectParam, textureManager.ink);
                }
            
                var newTime = Date.now();
                var dt = (newTime - time)/1000.0;
                time = newTime;
                timeThisFrame += dt;
                solvesThisFrame++;
                
                dt = dt * document.getElementById('speedup').value;
                //dt = 0.01;
                frameNumber++;
                if (time - frameStart > 500) {
                    document.getElementById('fps').innerHTML = 1000*frameNumber/(time - frameStart) + ' dt=' + dt;
                    frameNumber = 0;
                    frameStart = time;
                }
                
                var dtBinding = {
                    type: 'uniform1f',
                    name: 'dt',
                    value: dt  
                };
                
                solver.go(perturbProgram, [dtBinding, currentTextureParam(), textureParam('affectedField', textureManager.ink())], textureManager.vectorField);
                
                solver.go(advectProgram, [dtBinding, currentTextureParam(), textureParam('affectedField', textureManager.ink())], textureManager.ink);
                solver.go(advectProgram, [dtBinding, currentTextureParam(), textureParam('affectedField', textureManager.vectorField())], textureManager.vectorField);
                
                var diffusionCoeffecient = 0.000001;
                var alpha = dt * diffusionCoeffecient * 256 * 256;
                var beta = 1 + 4 * alpha;
                //solveLinearSystem(textureManager.vectorField, textureManager.vectorField, textureManager.vectorField, alpha, beta); // Diffuse
                                
                solver.go(divergenceProgram, [dtBinding, currentTextureParam()], textureManager.divergenceField);
                
                alpha = 1;
                beta = 4;
                solveLinearSystem(textureManager.divergenceField, textureManager.pressure, textureManager.pressure, alpha, beta); // Pressure
                
                solver.go(subtractPressureGradientProgram, [dtBinding, currentTextureParam(), {
                    name: 'pressure',
                    type: 'texture',
                    value: textureManager.pressure()
                }], textureManager.vectorField);
                
            }
            debugTexture('ink');
            debugTexture('vectorField');
            debugTexture('pressure');
            debugTexture('divergenceField');
            drawProgram.go([textureParam('vectorField', textureManager.ink())]);
            
        }, 0);
    }, 100);
}

function initGl(canvas) {
    try {
        gl = canvas.getContext('experimental-webgl');
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    } catch(e) {
    }
    
    if (!gl) alert("Could not create gl context - try and use a real browser");
}

function createRenderTargetTexture(size, initialData) {if (!gl.getExtension('OES_texture_float')) {
    var text = 'This demo requires the OES_texture_float extension';
        handleError(text);
        throw text;
      }
  
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); // Linear?
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.FLOAT, initialData);
    gl.bindTexture(gl.TEXTURE_2D, null);
    return texture;

}

function createTextureFromImage(src) {
    var texture = gl.createTexture();
    texture.image = new Image();
    texture.image.onload = function() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    };
    texture.image.src = src;
    return texture;
};

</script>
<style>
    canvas { 
        border: 1px solid white;
        width: 256px; 
        height: 256px; 
    }
    body {
        background: #888;
    }
    img.texture {
        width: 256px; height: 256px;
    }
</style>
</head>
<body onload="webGlStart()">
<h1>jFluidic</h1>
<canvas id="dest" width=256 height=256>
</canvas><br />
<img class="texture" id="ink" title="Ink" />
<img class="texture" id="vectorField" title="Vector Field" />
<img class="texture" id="pressure" title="Pressure" />
<img class="texture" id="divergenceField" title="Divergence" />

<br />
FPS: <span id="fps"></span><br />
Speedup: <input type="number" id="speedup" value="1" />
<br /><label><input type="checkbox" checked="checked" id="go" /> Go</label>
<br /><label><input type="checkbox" checked="checked" id="single-step" /> Single step per frame (~60fps always)</label>
<br /><label><input type="checkbox" achecked="checked" id="debug-ink" /> Debug Ink</label>
<br /><label><input type="checkbox" achecked="checked" id="debug-vectorField" /> Debug Field</label>
<br /><label><input type="checkbox" achecked="checked" id="debug-pressure" /> Debug Pressure</label>
<br /><label><input type="checkbox" achecked="checked" id="debug-divergenceField" /> Debug Div</label>

</body>
</html>